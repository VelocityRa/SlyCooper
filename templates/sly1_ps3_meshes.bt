//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: 
//   Authors: revel8n, VelocityRa
//   Version:
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

// TODO: SZME
// TODO: Sanity-check that index_data is always sequential

//
// Initialization
//

LittleEndian();
DisplayFormatHex();

local int parse_meshes = false;
local int parse_entities_experimental = false;
local int sly_version = 1;

//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}

//
// Type definitions (and Read functions)
//

// Common types

typedef struct bvec4_t
{
    uchar x, y, z, w;
} bvec4 <read=read_bvec4, bgcolor=cDkPurple>;
string read_bvec4(bvec4 &v) {
    string s;
    SPrintf(s, "[%02X %02X %02X %02X]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cDkPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    byte pad[pad_size];
} align;


// SZMS stuff

typedef struct szms_header_t (uint16 flags)
{
    char magic[4] <hidden=true>;
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct vertex_t
{
    vec3 pos;
    vec3 normal;
    vec2 texcoord;
    uint32 color;
} vertex <read=read_vertex, bgcolor=cDkPurple>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos.x, v.pos.y, v.pos.z, v.normal.x, v.normal.y, v.normal.z,
        v.texcoord.x,  v.texcoord.y, v.color);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cPurple>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 index_data_offset_0;
    uint32 index_data_offset_1;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.index_data_offset_0, v.index_data_offset_1);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr;

    FSeek(start_offset + index_hdr.index_data_offset_0);
    uint16  triangle_data[index_hdr.triangle_count * 3];

    FSeek(start_offset + index_hdr.index_data_offset_1);
    uint16  index_data[index_hdr.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];
    Assert(sizeof(vertices) == vertex_hdr.vertex_data_size);

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

local uint16 g_flags = 0;

typedef struct szme_vertex_data_t {
    vec3 origin;
    float unk_float;
    ubyte unk_count1;
    ubyte unk_count2;
    ubyte unk_count3;
    ubyte unk_count4;
    ubyte unk_count5;

    align _pad(4);

    vec3 positions[unk_count1];
    vec3 rotations[unk_count2];
    uint32 unk_color[unk_count3];
    vec2 texcoords[unk_count4];
    bvec4 lighting[unk_count5];

    uint16 texture_id;

    byte unk_u8_1;
    ubyte unk_count6;

    ubyte unk_bytes[unk_count6]; // gets converted to floats
    float unk_floats[unk_count6 * unk_count1];

    // TODO: field_0x40
} szme_vertex_data <optimize=false>;

typedef struct after_szme_data_t {

    ubyte unk_count;
    vec3 unk_vec[unk_count];

    ubyte unk_count2;
    uint32 unk_u32[unk_count2];

    ubyte unk_count3;
    ubyte unk_u8[unk_count3];
} after_szme_data <bgcolor=cAqua>;

typedef struct meta_entry_alt_t {
    uint16 type_maybe;

    if (type_maybe != 0) {
        ubyte unk[0x1C];
    }
} meta_entry_alt <bgcolor=cAqua>;

typedef struct szme_header2_t (uint16 flags) {
    if ((flags & 2) != 0) {
        uint32 unk_0x04 <bgcolor=cAqua>;
    }
    if ((flags & 0x200) != 0) {
        float unk_float;
    }
    if ((flags & 4) != 0) {
        float unk_float2;
    }
    if ((flags & 8) != 0) {
        float unk_float3;
    }
    if ((flags & 0x10) != 0) {
        float unk_float4;
    }
    if ((flags & 0x20) != 0) {
        float unk_float5;
    }
    if ((flags & 0x40) != 0) {
        // meta entry alt
        //Assert(false);
        Printf("flags & 0x40 (meta_entry_alt) at 0x%X\n", FTell());
        meta_entry_alt meta_entry_alt_;
    }
    if ((flags & 0x80) != 0) {
        vec3 unk_vec3;
        vec4 unk_vec4;
    }
    if ((flags & 0x100) != 0) {
        // TODO
        Printf("flags & 0x100 unsupported, skipping everything\n");
        Assert(false);
    } else {
        vec3 position;
        float unk_0x14 <bgcolor=cAqua>;
        uint16 unk_0x16_ignore <bgcolor=cAqua>;
        byte unk_0x1A <bgcolor=cAqua>;
        byte unk_0x1B <bgcolor=cAqua>;
        byte unk_0x1C <bgcolor=cAqua>;
    
        if ((flags & 1) == 0) {
            uint16 mesh_count;
            //align _align(4);

            szme_vertex_data szme_data[szme_hdr.mesh_count];

            uint16 unk_count;
            after_szme_data after_szme_data_[unk_count];
        }
    }
} szme_header2;
string read_szme_header2(szme_header2 &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "szme#: %d", v.mesh_count);
    }
    return s;
}

typedef struct mesh_data_t
{
    // only on primary SZMS
    //ubyte unk_count; // not always right
    //uint16 unk_u16;
    uint16 flags;
    g_flags = flags;

    if (sly_version == 2)
        uint16 unk;

    if ((flags & 1) == 0) {
        szms_header szms (flags);

        local int64 start_offset = FTell();
    
        mesh_header mesh_hdr;
    
        local uint32 i = 0;
        for (i = 0; i < mesh_hdr.mesh_count; ++i)
        {
            FSeek(start_offset + mesh_hdr.mesh_offsets[i]);
    
            vertex_data vertex_data_(start_offset);
        }
    
        char magic[4];
    } else {
        // TODO
        uint16 unk_u16;
        // align?
        vec3 unk_mat4_0;
        vec3 unk_mat4_1;
        vec3 unk_mat4_2;
        vec3 unk_mat4_3;
    }

    szme_header2 szme_hdr(flags);

    //if ((flags & 0x100) == 0) { // TODO: remove when we parse 0x100 case
        //if (szme_hdr.mesh_count < 0xFF) { // todo
            //szme_vertex_data szme_data[szme_hdr.mesh_count];

            //uint16 unk_count;
            //after_szme_data after_szme_data_[unk_count];
        //}
    //} else {
    //    Assert(true, "0x100 case");
    //}

} mesh_data <read=read_mesh_data, bgcolor=cDkGray, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;

    SPrintf(s, "flags: %02X", v.flags);

    if ((v.flags & 1) == 0) {
        SPrintf(s, "%s %s", s, read_szms_header(v.szms));
        SPrintf(s, "%s %s", s, read_mesh_header(v.mesh_hdr));
        SPrintf(s, "%s %s", s, read_szme_header2(v.szme_hdr));
    } else {
        // TDDO
    }

    //SPrintf(s, "%s", s);
    return s;
}

//
// Object allocation
//

if (parse_meshes) {

local TFindResults szms_res = FindAll("SZMS");

local int i;
local int j;
local int m_start;

for (i = 0; i < szms_res.count; i++ ) {
    if (sly_version == 2)
        m_start = szms_res.start[i] - 4;
    else
        m_start = szms_res.start[i] - 4;

    FSeek(m_start);
    mesh_data mesh;


/*
    Printf("SZMS #%04d %05X at %08X | mesh hdr unk: %08X %04X | vert hdr unk: ",
        i, mesh.header.data_size, m_start, mesh.mesh_hdr.unknown_0x00,
        mesh.mesh_hdr.unknown_0x04);

    for (j = 0; j < mesh.mesh_hdr.mesh_count; j++) {
        Printf("[%08X %04X] ",
            mesh.vertex_data_[j].vertex_hdr.unknown_0x10,
            mesh.vertex_data_[j].vertex_hdr.unknown_count);
    }

    Printf("\n");
*/

/*
    Printf("SZME #%04d at %08X | %08X %9.2f %9.2f %9.2f %9.2f %08X %08X %7.2f %08X %08X %02X%02X%02X %02X%02X%02X %02X ",
        i, m_start,
        mesh.szme_data_.szme_hdr.unk_0x04,

        mesh.szme_data_.szme_hdr.unk_0x08,
        mesh.szme_data_.szme_hdr.unk_0x0C,
        mesh.szme_data_.szme_hdr.unk_0x10,
        mesh.szme_data_.szme_hdr.unk_0x14,

        mesh.szme_data_.szme_hdr.unk_0x18,
        mesh.szme_data_.szme_hdr.unk_0x1C,

        mesh.szme_data_.szme_hdr.unk_0x20,

        mesh.szme_data_.szme_hdr.unk_0x24,
        mesh.szme_data_.szme_hdr.unk_0x28,

        mesh.szme_data_.szme_hdr.unk_0x2C[0],
        mesh.szme_data_.szme_hdr.unk_0x2C[1],
        mesh.szme_data_.szme_hdr.unk_0x2C[2],

        mesh.szme_data_.szme_hdr.unk_0x30[0],
        mesh.szme_data_.szme_hdr.unk_0x30[1],
        mesh.szme_data_.szme_hdr.unk_0x30[2],

        mesh.szme_data_.szme_hdr.unk_count);

    for (j = 0; j < mesh.mesh_hdr.mesh_count; j++) {
        Printf("[%08X %04X] ",
            mesh.vertex_data_[j].vertex_hdr.unknown_0x10,
            mesh.vertex_data_[j].vertex_hdr.unknown_count);
    }

    Printf("\n");
*/

}

}

// 

struct szms_container (int count) {
    mesh_data mesh[count];
    ubyte todo;
};

struct szms_container_container {
    ubyte unk_count;
    uint32 unk_u32s[unk_count];
    uint16 szms_count <bgcolor=cRed>;
    szms_container cont (szms_count);
};

local int i = 0;
local int64 szms_start;
local int64 szms_start_real;
local int64 szms_start_maybe;

while (true) {
    szms_start = FindFirst("SZMS", true, false, 0, 0.0, 1, FTell());
    if (szms_start == -1)
        break;

    szms_start_real = szms_start - 5;
    for (i = 1; i < 15; i++) {
        szms_start_maybe = szms_start - 4 - (i * 4 + 1);

        if (ReadUByte(szms_start_maybe) == i) {
            szms_start_real = szms_start_maybe;
            Printf("[0x%X] found\n", szms_start_real);
            break;
        } else {
            Printf("no\n");
        }
    }

    Printf("[0x%X] SZMS container\n", szms_start_real);

    FSeek(szms_start_real);
    szms_container_container szms;
}

/*
local int is_fist_szms = true;
local int cur_szmz_count = 0;

local TFindResults szms_res = FindAll("SZMS");

local int i;
local int j;
local int m_start;

//FSeek(szms_res.start[0] - 4);
FSeek(0x40f605);
uint16 szms_count <bgcolor=cRed>;
szms_container cont (szms_count);
*/

/*
FSeek(szms_res.start[0] - 4);

for (i = 0; i < szms_res.count; i++ ) {
    if (cur_szmz_count == 0) {
        uint16 szmz_count <bgcolor=cRed>;
        cur_szmz_count = szmz_count;
    }


    m_start = szms_res.start[i] - 2;

    FSeek(m_start);
    mesh_data mesh;

    cur_szmz_count -= 1;
}
*/

//

typedef struct light_t {
    // todo mat3
    vec3 mat0_0;
    vec3 mat0_1;
    vec3 mat0_2;

    vec3 position <bgcolor=cDkRed>;
    ubyte unkB0; // 3 bits
    ubyte unkB1; // 3 bits
    ubyte unkB2; // 3 bits
    uint32 unkUint;

    float unkF0;
    float unkF1;

    float unkF2;
    float unkF3;
    
    //

    uint16 unkUint2;
    if (unkUint == 0x3B) {
        hexdump(FTell(), 2);
        ubyte unk1[3];
    }


    hexdump(FTell(), 79-2);
    ubyte unk2[79-2];
    Printf("\n");
} light <optimize=false, bgcolor=cAqua>;

typedef struct coinUnk_t {
    uint16 u0;
    if (u0 == (uint16)-1) {
        uint16 u1;
    } else {
        uint16 u2;
        uint16 u3;
        // TODO ?

        uint16 u4;
    }
} coinUnk <optimize=false, bgcolor=cDkAqua>;

typedef struct coinUnk2_t {
    uint16 u0;
    uint16 u1;
    uint32 u2;
    ubyte u3;

    if (u3 == 2)
        float u4;

    // TODO: unpacks_additonal_light_info?
} coinUnk2 <optimize=false, bgcolor=cDkAqua>;

typedef struct coin_t {
    // todo mat3
    vec3 mat0_0;
    vec3 mat0_1;
    vec3 mat0_2;

    vec3 position <bgcolor=cDkRed>;

    ubyte unkCount;
    coinUnk cUnk[unkCount];

    ubyte unkCount2;
    coinUnk2 cUnk[unkCount2];

    ubyte unk[0xA];
} coin <optimize=false, bgcolor=cAqua>;

if (parse_entities_experimental)  {

FSeek(0x8D61C4);
light u[20];

FSeek(0x008D44D8);
light u2;

FSeek(0x0093B35E);
coin c[47];

}

