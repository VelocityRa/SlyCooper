//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: 
//   Authors: revel8n, VelocityRa
//   Version:
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

// TODO: SZME
// TODO: Sanity-check that index_data is always sequential

//
// Initialization
//

LittleEndian();
DisplayFormatHex();

//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}

//
// Type definitions (and Read functions)
//

// Common types

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cDkPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    byte pad[pad_size];
} align;


// SZMS stuff

typedef struct szms_header_t (uint16 flags)
{
    char magic[4] <hidden=true>;
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct normal_t_ {
    float nx, ny, nz;
} normal_t <read=read_normal>;
string read_normal(normal_t &v) {
    string s;
    SPrintf(s, "%4.3f \t%4.3f \t%4.3f   \t%4.3f",
        v.nx, v.ny, v.nz,
        v.nx*v.nx+ v.ny*v.ny+ v.nz*v.nz);
    return s;
}

typedef struct vertex_t
{
    float pos_x, pos_y, pos_z;
    normal_t normal;
    float texcoord_u, texcoord_v;
    uint32 unk_0x20 <bgcolor=cAqua>;
} vertex <read=read_vertex, bgcolor=cDkPurple>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos_x, v.pos_y, v.pos_z, v.normal.nx, v.normal.ny, v.normal.nz,
        v.texcoord_u,  v.texcoord_v, v.unk_0x20);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cPurple>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 index_data_offset_0;
    uint32 index_data_offset_1;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.index_data_offset_0, v.index_data_offset_1);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr;

    FSeek(start_offset + index_hdr.index_data_offset_0);
    uint16  triangle_data[index_hdr.triangle_count * 3];

    FSeek(start_offset + index_hdr.index_data_offset_1);
    uint16  index_data[index_hdr.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];
    Assert(sizeof(vertices) == vertex_hdr.vertex_data_size);

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

local uint16 g_flags = 0;

typedef struct szme_header2_t (uint16 flags) {
    char magic[4];
    if ((flags & 2) != 0) {
        uint32 unk_0x04 <bgcolor=cAqua>;
    }
    if ((flags & 0x200) != 0) {
        float unk_float;
    }
    if ((flags & 4) != 0) {
        float unk_float2;
    }
    if ((flags & 8) != 0) {
        float unk_float3;
    }
    if ((flags & 0x10) != 0) {
        float unk_float4;
    }
    if ((flags & 0x20) != 0) {
        float unk_float5;
    }
    if ((flags & 0x40) != 0) {
        // meta entry alt
        //Assert(false);
        Printf("flags & 0x40 unsupported, skipping\n");
        FSeek(FTell() + 0x1C);
    }
    if ((flags & 0x80) != 0) {
        vec3 unk_vec3;
        vec4 unk_vec4;
    }
    if ((flags & 0x100) != 0) {
        // TODO
        //Assert(false);
        Printf("flags & 0x100 unsupported, skipping everything\n");
    } else {
        vec3 position;
        float unk_0x14 <bgcolor=cAqua>;
        uint16 unk_0x16_ignore <bgcolor=cAqua>;
        byte unk_0x1A <bgcolor=cAqua>;
        byte unk_0x1B <bgcolor=cAqua>;
        byte unk_0x1C <bgcolor=cAqua>;
    
        if ((flags & 1) == 0) {
            uint16 mesh_count;
        }
    }
} szme_header2;
string read_szme_header2(szme_header2 &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "mesh_count: %d", v.mesh_count);
    }
    return s;
}

typedef struct szme_vertex_data_t {
    vec3 unk_vec;
    float unk_float;
    ubyte unk_count1;
    ubyte unk_count2;
    ubyte unk_count3;
    ubyte unk_count4;
    ubyte unk_count5;

    align _pad(4);

    vec3 positions[unk_count1];
    vec3 rotations[unk_count2];
    uint32 unk_color[unk_count3];
    vec2 texcoords[unk_count4];
    uint32 lighting[unk_count5];

    uint16 texture_id;

    byte unk_u8_1;
    byte unk_u8_2;
} szme_vertex_data <optimize=false>;

typedef struct mesh_data_t
{
    uint16 flags;

    g_flags = flags;

    if ((flags & 1) == 0) {
        szms_header szms (flags);

        local int64 start_offset = FTell();
    
        mesh_header mesh_hdr;
    
        local uint32 i = 0;
        for (i = 0; i < mesh_hdr.mesh_count; ++i)
        {
            FSeek(start_offset + mesh_hdr.mesh_offsets[i]);
    
            vertex_data vertex_data_(start_offset);
        }

        szme_header2 szme_hdr(flags);

        if ((flags & 0x100) == 0) { // TODO: remove when we parse 0x100 case
            if ((flags & 1) == 0) {
                if (szme_hdr.mesh_count < 0xFF) { // todo
                    szme_vertex_data szme_data[szme_hdr.mesh_count];
                }
            }
        }
    } else {
        // TODO
    }

} mesh_data <read=read_mesh_data, bgcolor=cDkGray, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;

    SPrintf(s, "flags: %02X", v.flags);

    if ((v.flags & 1) == 0) {
        SPrintf(s, "%s %s", s, read_szms_header(v.szms));
        SPrintf(s, "%s %s", s, read_mesh_header(v.mesh_hdr));
    } else {
    }

    //SPrintf(s, "%s", s);
    return s;
}

//
// Object allocation
//

local TFindResults szms_res = FindAll("SZMS");

local int i;
local int j;
local int m_start;

for (i = 0; i < szms_res.count; i++ ) {
    m_start = szms_res.start[i] - 2;

    FSeek(m_start);
    mesh_data mesh;

/*
    Printf("SZMS #%04d %05X at %08X | mesh hdr unk: %08X %04X | vert hdr unk: ",
        i, mesh.header.data_size, m_start, mesh.mesh_hdr.unknown_0x00,
        mesh.mesh_hdr.unknown_0x04);

    for (j = 0; j < mesh.mesh_hdr.mesh_count; j++) {
        Printf("[%08X %04X] ",
            mesh.vertex_data_[j].vertex_hdr.unknown_0x10,
            mesh.vertex_data_[j].vertex_hdr.unknown_count);
    }

    Printf("\n");
*/

/*
    Printf("SZME #%04d at %08X | %08X %9.2f %9.2f %9.2f %9.2f %08X %08X %7.2f %08X %08X %02X%02X%02X %02X%02X%02X %02X ",
        i, m_start,
        mesh.szme_data_.szme_hdr.unk_0x04,

        mesh.szme_data_.szme_hdr.unk_0x08,
        mesh.szme_data_.szme_hdr.unk_0x0C,
        mesh.szme_data_.szme_hdr.unk_0x10,
        mesh.szme_data_.szme_hdr.unk_0x14,

        mesh.szme_data_.szme_hdr.unk_0x18,
        mesh.szme_data_.szme_hdr.unk_0x1C,

        mesh.szme_data_.szme_hdr.unk_0x20,

        mesh.szme_data_.szme_hdr.unk_0x24,
        mesh.szme_data_.szme_hdr.unk_0x28,

        mesh.szme_data_.szme_hdr.unk_0x2C[0],
        mesh.szme_data_.szme_hdr.unk_0x2C[1],
        mesh.szme_data_.szme_hdr.unk_0x2C[2],

        mesh.szme_data_.szme_hdr.unk_0x30[0],
        mesh.szme_data_.szme_hdr.unk_0x30[1],
        mesh.szme_data_.szme_hdr.unk_0x30[2],

        mesh.szme_data_.szme_hdr.unk_count);

    for (j = 0; j < mesh.mesh_hdr.mesh_count; j++) {
        Printf("[%08X %04X] ",
            mesh.vertex_data_[j].vertex_hdr.unknown_0x10,
            mesh.vertex_data_[j].vertex_hdr.unknown_count);
    }

    Printf("\n");
*/
}
