
//
// Initialization
//

LittleEndian();
DisplayFormatHex();

local int parse_meshes = false;
local int parse_entities_experimental = false;


//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}


//
// Type definitions (and Read functions)
//

// Common types

typedef ubyte u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;
typedef byte s8;
typedef int16 s16;
typedef int32 s32;
typedef int64 s64;
typedef float f32;
typedef double f64;

typedef struct bvec4_t
{
    uchar x, y, z, w;
} bvec4 <read=read_bvec4, bgcolor=cLtBlue>;
string read_bvec4(bvec4 &v) {
    string s;
    SPrintf(s, "[%02X %02X %02X %02X]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct uvec3_t
{
    uint32 x, y, z;
} uvec3 <read=read_uvec3, bgcolor=cDkBlue>;
string read_uvec3(uvec3 &v) {
    string s;
    SPrintf(s, "[%d %d %d]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct svec2_t
{
    uint16 x, y;
} svec2 <read=read_svec2, bgcolor=cDkBlue>;
string read_svec2(svec2 &v) {
    string s;
    SPrintf(s, "[%d %d %d]", v.x, v.y);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    if (pad_size != 0)
        byte pad[pad_size];
} align <optimize=false>;


// SZMS stuff

typedef struct szms_header_t
{
    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'S');
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow, optimize=false>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue, optimize=false>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct vertex_t
{
    vec3 pos;
    vec3 normal;
    vec2 texcoord;
    uint32 color;
} vertex <read=read_vertex, bgcolor=cLtPurple, optimize=false>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos.x, v.pos.y, v.pos.z, v.normal.x, v.normal.y, v.normal.z,
        v.texcoord.x,  v.texcoord.y, v.color);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cLtYellow, optimize=false>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 triangle_data_offset;
    uint32 index_data_offset;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.triangle_data_offset, v.index_data_offset);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr1;
    index_header index_hdr2;

    FSeek(start_offset + index_hdr1.triangle_data_offset);
    uint16  triangle_data1[index_hdr1.triangle_count * 3];

    FSeek(start_offset + index_hdr1.index_data_offset);
    uint16  index_data1[index_hdr1.index_count];

    // wrong?

    FSeek(start_offset + index_hdr2.triangle_data_offset);
    if (index_hdr2.triangle_count > 0)
        uint16  triangle_data2[index_hdr2.triangle_count * 3];

    FSeek(start_offset + index_hdr2.index_data_offset);
    uint16  index_data2[index_hdr2.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen, optimize=false>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua, optimize=false>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

typedef struct e2_t {
    u32 f0;
    u16 f1;
} e2;

typedef struct j10_t {
    u16 j1_cnt;
    svec2 j1;
} j10 <optimize=false, bgcolor=cDkRed>;

typedef struct j9_t  {
    u16 j0_cnt;

    if (j0_cnt > 0)
        j10 j0_[j0_cnt];
} j9 <optimize=false, bgcolor=cDkGreen>;

typedef struct k11_t {
    u16 k0;
    u16 k1;
    u8 k2;
} k11 <optimize=false, bgcolor=cDkGreen>;

typedef struct k10_t {
    u16 k11_cnt;
    k11 k11_[k11_cnt];
} k10 <optimize=false, bgcolor=cDkRed>;

struct k13 {
    u16 k0_cnt;
    if (k0_cnt > 0) {
        k10 k0_[k0_cnt];
        u16 k12_cnt;
        u16 k12[k12_cnt];
    }
};

typedef struct u2_t (u8 i0) {
    u8 g0;

    if (i0 == 0)
        u32 g1;
    u16 g2;
    
    vec3 g3_mat4_0;
    vec3 g3_mat4_1;
    vec3 g3_mat4_2;
    vec3 g3_mat4_3;

    u32 g4;

    u8 g5_ign;

    k13 k13_;
} u2 <optimize=false, bgcolor=cBlue>;

u8 min(u8 x, u8 y) {
    if (x < y)
        return x;
    else
        return y;
}

typedef struct szme_data_t (u8 flags, u16 u2_cnt, u8 e2_cnt, u8 i0) {
    u8 a0_cnt;

    local uint a0_unk_cnt = 0;

    local int i = 0;
    for (i = 0; i < a0_cnt; i++) {
        uvec3 a0;
        a0_unk_cnt += a0.x;
    }

    u8 vertex_count;
    if (vertex_count > 0) {
        vec3 positions[vertex_count];
        vec2 texcoords[vertex_count];
        vec3 normals[vertex_count];
        uint32 a4[vertex_count];
    }

    u8 a5;

    if (e2_cnt != 0) {
        u8 a7[4];

        local u8 e2_cnt_mn = min(e2_cnt, 4);
        u8 a8[vertex_count * e2_cnt_mn];
    }

    if (a0_unk_cnt > 0)
        u8 indices_unk[a0_unk_cnt];

    local u32 uVar28 = a0_unk_cnt + 0x1f;
    local u32 a6_uint_cnt = ((int)uVar28 >> 5) + (uint)((int)uVar28 < 0 && (uVar28 & 0x1f) != 0);
    if (a6_uint_cnt > 0)
        u32 a6[a6_uint_cnt];

// TODO: remove?
    //if (u2_cnt > 0)
    //    u2 u2_ (flags, i0) [u2_cnt];
} szme_data <optimize=false, bgcolor=cYellow>;

typedef struct d9_t {
    u16 d9_0;
    u16 d9_1;
    u8 d9_2;
} d9 <optimize=false, bgcolor=cLtRed>;

typedef struct d7_t {
    u16 d9_cnt;
    if (d9_cnt > 0)
        d9 d9_[d9_cnt];
} d7 <optimize=false, bgcolor=cLtBlue>;

typedef struct szme_t (u16 u2_cnt, u8 i0) {
    u8 flags;
    u16 e1;
    u8 e2_cnt;
    if (e2_cnt > 0)
        e2 e2_[e2_cnt];
    
    u8 e3;

    if (e3 != 0xFF) {
        vec3 e4;
        vec2 e5;
        vec3 e6;
    }

    k13 k13_;

    if ((flags & 4) != 0) {
        u32 e7;
        u8 e8;

        if (e8 != 0xFF) {
            u32 e9;
            u32 e10;
            u32 e11;
            u32 e12;

            vec3 e13_mat4_0;
            vec3 e13_mat4_1;
            vec3 e13_mat4_2;
            vec3 e13_mat4_3;
        }

        u8 e14;
        u8 e15;
        u8 e16;
    }

// todo
/*
    u16 d7_cnt;
    if (d7_cnt != 0) {
        d7 d7_[d7_cnt];

        u16 d8_cnt;
        u16 d8[d8_cnt];
    }
*/
    u16 szme_data_cnt;
    szme_data szme_data_ (flags, u2_cnt, e2_cnt, i0) [szme_data_cnt];
} szme <optimize=false, bgcolor=cLtGreen>;
string read_szme_t(szme_t &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "szme#: %d", v.mesh_count);
    }
    return s;
}

typedef struct mesh_data_t0_t (u16 u2_cnt, u8 i0) {
    szms_header szms;

    local int64 start_offset = FTell();

    mesh_header mesh_hdr;

    local uint32 i = 0;
    for (i = 0; i < mesh_hdr.mesh_count; ++i)
    {
        FSeek(start_offset + mesh_hdr.mesh_offsets[i]);

        vertex_data vertex_data_(start_offset);
    }

    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'E');

    szme szme_ (u2_cnt, 0);
} mesh_data_t0 <open=true, bgcolor=cDkRed, open=true>;

local int skip_mco = false;

typedef struct mesh_data_t (ubyte i0)
{
    ubyte u0;

    if (u0 == 0) {
        ubyte type;
        uint16 u2_cnt;
        uint16 u3;
        ubyte u3_;
        f32 u4;
        f32 u5;
        uint32 u6;
        ubyte u7_ign;
        ubyte u8_;

        if (i0 == 0) {
            vec3 u9;
            float u10;
            u32 u11;
            float u12;
        }
        if (type == 0) {
             mesh_data_t0 t0 (u2_cnt, i0);
        } else if (type == 1) {
            //Assert(false, "type == 1"); // TODO
            Printf("[%06X] TODO: type == 1\n", FTell());
            skip_mco = true;
        } else if (type == 2) {
            //Assert(false, "type == 2"); // TODO
            Printf("[%06X] TODO: type == 2\n", FTell());
            skip_mco = true;
        } else if (type == 3) {
            //Assert(false, "type == 3"); // TODO
            Printf("[%06X] TODO: type == 3\n", FTell());
            skip_mco = true;
        } else {
            Assert(false);
        }
        if (skip_mco)
            break;
        if (u2_cnt > 0)
            u2 u2_ (i0) [u2_cnt];
    } else {
        u16 u1_alt[u0];
        u32 u2_ign_cnt;
        if (u2_ign_cnt > 0)
            u8 u2_ign[u2_ign_cnt];
    }
} mesh_data <read=read_mesh_data, bgcolor=cDkYellow, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;
    if (v.u0 == 0) {
        SPrintf(s, "type: %d u2: %d", v.type, v.u2_cnt);
    } else {
        SPrintf(s, "u0: %d", v.u0);
    }
    return s;
}

typedef struct o_t {
    u8 o1;

    if (o1 != 0xFF) {
        vec3 o2;
        f32 o3;
        f32 o4;
        u8 o5;
        u16 o6;
    }
} o <bgcolor=cLtGreen, optimize=false>;

typedef struct mesh_data_unk3_t {
    u16 count;

    // TODO
    skip_mco = true;
    break;

    local int i = 0;
    while (i < count) {
        o o_;
        if (o_.o1 != 0xFF)
            i++;
    }
} mesh_data_unk3 <bgcolor=cGreen, optimize=false>;

typedef struct i3_t {
    u16 i3_0;
    if ((((int)i3_0) & 0xFFFF) != 0xffffffff) // wat
        u8 i3_1[0x20];
} i3 <bgcolor=cBlue, optimize=false>;

typedef struct mesh_container_t {
    ubyte i0;
    vec3 i1;
    float i2;
    ubyte i3_cnt;
    if (i3_cnt > 0)
        i3 i3_[i3_cnt];
    ubyte i4;

    uint16 mesh_count <bgcolor=cRed>;
    local int i = 0;
    local int mesh_count_actual = 0;
    local int do_break = false;
    while (i < mesh_count) {
        mesh_data mesh (i0);
        mesh_count_actual++;
        if (skip_mco) {
            do_break = true;
            break;
        }
        if (mesh.u0 == 0) {
            //Printf("i [%d] += mesh.u2_cnt [%d]\n", i, mesh.u2_cnt);
            i += mesh.u2_cnt;
        } else {
            //Printf("i++ [d] [%d]\n", i, i+1);
            i--;
        }
        i++;
    }
    if (do_break)
        break;
    mesh_data_unk3 mesh_data_unk3_;
} mesh_container <bgcolor=cDkGreen, read=read_mesh_container, optimize=false, open=true>;
string read_mesh_container(mesh_container &v) {
    string s;
    SPrintf(s, "mesh# %d types ", v.mesh_count);
    local int i;
    for (i = 0; i < v.mesh_count_actual; i++) {
        if (v.mesh[i].u0 == 0)
            SPrintf(s, "%s %d", s, v.mesh[i].type);
        else
            SPrintf(s, "%s [%d]", s, v.mesh[i].u0);
    }

    return s;
}


typedef struct mesh_container_outer_c2_t {
    u16 c3;
    u16 c4;
    u32 c5;
    u8 flags;
    if ((flags & 1) == 0) {
        if ((flags & 2) != 0) {
            f32 c6;
            f32 c7;
        }
    } else {
        f32 c8;
    }
    if ((flags & 4) != 0) {
        u8 c9;
    }
    if ((flags & 8) != 0) {
        u8 c10;
        f32 c11;
        vec3 c12_mat_0;
        vec3 c12_mat_1;
        vec3 c12_mat_2;
        vec3 c12_mat_3;
        u8 c13;
        u8 c14;
        u32 c15;
    }
    if ((flags & 0x10) != 0) {
        u8 c16;
        f32 c17;
        f32 c18;
    }
    if ((flags & 0x20) != 0) {
        vec3 c19;
    }
    if (c4 < 0x10) {
        local u64 uVar8 = 1 << ((u64)(u32)c4 & 0x7F);
        if ((uVar8 & 0xA001) == 0) {
            if ((uVar8 & 0x4100) == 0) {
                vec3 c22_mat_0;
                vec3 c22_mat_1;
                vec3 c22_mat_2;
                vec3 c22_mat_3;
            } else {
                u16 c20;
            }
        } else {            
            vec3 c21_mat_0;
            vec3 c21_mat_1;
            vec3 c21_mat_2;
            vec3 c21_mat_3;
        }
    } else {        
        vec3 c22_mat_0;
        vec3 c22_mat_1;
        vec3 c22_mat_2;
        vec3 c22_mat_3;
    }
} mesh_container_outer_c2 <bgcolor=cDkRed, optimize=false, read=read_mesh_container_outer_c2>;
string read_mesh_container_outer_c2(mesh_container_outer_c2 &v) {
    string s;
    SPrintf(s, "flags: %02X c: %04X %04X %08X",
        v.flags, v.c3, v.c4, v.c5);
    return s;
}

typedef struct ca_t {
    u16 ca0;
    u16 ca1;
    u16 ca2;
    vec3 ca3;
    u16 ca4;
    vec3 ca5;
} ca <bgcolor=cRed>;
typedef struct cb_t {
    u16 cb0;
    u16 cb1;
    u8 cb2;
    u8 cb3;
} cb <bgcolor=cDkRed>;
typedef struct cc_t {
    u8 cc0;
    f32 cc1;
    f32 cc2;
    f32 cc3;
    f32 cc4;
    vec3 cc5;
    vec3 cc6;
    u8 cc7_cnt;
    if (cc7_cnt > 0)
        u16 cc7[cc7_cnt];
} cc <bgcolor=cAqua>;

typedef struct cd5_t {
    u16 cd5_0;
    u16 cd5_1;
    u16 cd5_2;
} cd5 <bgcolor=cDkBlue>;

typedef struct cd_t {
    u16 cd0;
    u16 cd1_ign;
    u16 cd2_ign;
    f32 cd3_ign[4]; // ?
    u8 cd4;
    if (cd4 > 0)
        cd5 cd5_[cd4];
} cd <bgcolor=cDkYellow, optimize=false>;

typedef struct c6a_t {
    u16 c6a0_count;
    if (c6a0_count > 0)
        vec3 c6a0[c6a0_count];
    u16 cd_count;
    u16 c6a2;
    if (cd_count > 0)
        cd cd_[cd_count];
} c6a <bgcolor=cBlue>;

struct c7b {
    u16 c7b0;
    u32 c7b1;
    u32 c7b2;
};

typedef struct c7a_t {
    u32 c70;
    u32 c71;
    u32 c72;
    c7b c7b_[c70];
} c7a <bgcolor=cLtGreen>;

typedef struct c6_t {
    u16 c6_0;
    u32 c6_1;
    u8 c6_2;
    u8 c6_3;
    f32 c6_4;
    c6a c6a_;
    c7a c7a_;
    u32 c8a;
    u16 c9a;
    u16 c10a;
    u8 c11a;
} c6 <optimize=false, bgcolor=cLtRed, open=true>;

typedef struct c9_t {
    s16 d1;
    //Printf("d1 0x%X\n",d1);
    if (d1 >= 0) {
        local u16 uVar1 = (u64)(uint)((int)d1 << 3) + (u64)(uint)((int)d1 << 5);
        //Printf("uVar1 0x%X\n",uVar1);
    }
} c9 <optimize=false, bgcolor=cLtBlue>;

typedef struct mesh_container_outer_t {
    u16 c2_cnt;
    if (c2_cnt > 0)
        mesh_container_outer_c2 mco_c2[c2_cnt];

    u8 ca_count;
    if (ca_count > 0)
        ca ca_[ca_count];
    u8 cb_count;
    if (cb_count > 0)
        cb cb_[cb_count];
    u8 cc_count;
    if (cc_count > 0)
        cc cc_[cc_count];

    u16 c3;
    u16 c4;
    u16 c5;

    u32 c1;
    mesh_container mc;
    if (skip_mco) {
        Printf("skipp\n");
        break;
    }

    u16 c6_count;
    if (c6_count > 0) {
        c6 c6_[c6_count];
        f32 c7;
        vec3 c8_mat3_0;
        vec3 c8_mat3_1;
        vec3 c8_mat3_2;
    }

    c9 c9_;

} mesh_container_outer <bgcolor=cGreen, read=read_mesh_container_outer, optimize=false>;
string read_mesh_container_outer(mesh_container_outer &v) {
    string s;
    // TODO c6_count
    SPrintf(s, "c2# %d abc# %d %d %d mc: %s", 
        v.c2_cnt, v.ca_count, v.cb_count, v.cc_count, read_mesh_container(v.mc));
    return s;
}

//
// Object allocation
//

// todo: connect with obj names?

//FSeek(0x110828);
//mesh_container mc;

local int mco_offsets[351] = { 0x107E63,0x1106C3,0x1197A3,0x1345D3,0x136E69,0x138E5F,0x13B405,0x13BDB5,0x13DC69,0x158A26,0x158F1E,0x159416,0x160B1C,0x160EEA,0x161429,0x1D1DD3,0x1EB302,0x1EBCA4,0x1EBF97,0x1F1D12,0x1F2730,0x20E520,0x23BEC2,0x246A91,0x246F7D,0x247967,0x25B2D3,0x25CC85,0x25D451,0x26E423,0x28EB5C,0x28EFE1,0x2A831E,0x2A8EEC,0x2EAC0E,0x2EB3BE,0x2ECCF3,0x2ED867,0x2FDF82,0x2FE59C,0x310313,0x3244A3,0x373733,0x382E88,0x3834B9,0x38739B,0x387C56,0x391598,0x3926C4,0x39EA73,0x3A38B3,0x3A7FB3,0x3A9A93,0x3B3463,0x3B4D47,0x42A57E,0x42AB38,0x42BC90,0x42C6AE,0x43C489,0x43E48A,0x449583,0x47ED0C,0x47FF84,0x490222,0x490DF0,0x4E2436,0x530783,0x5346C3,0x5C5703,0x5C8175,0x5CB0E3,0x5CD9A3,0x5CDA15,0x5CDAE4,0x5D6ED3,0x5D96F3,0x5E06A3,0x634593,0x6DB3B3,0x739813,0x7D5158,0x7D5618,0x804323,0x8043B3,0x806C62,0x806E5A,0x816E33,0x823AD3,0x8349B3,0x8746DA,0x874E9F,0x875400,0x8828D3,0x892BB2,0x89309E,0x894149,0x8A79BC,0x8A8181,0x8A8856,0x8B9D32,0x8C1FF6,0x924B73,0x98A8C1,0x9955A0,0x99943E,0x9A5C7E,0x9AAC13,0x9B406E,0x9B785B,0x9C1B68,0x9C5928,0x9CDB42,0x9D06D4,0x9DAAB5,0x9DE7D7,0x9E8627,0x9EBC0B,0x9F2230,0x9F4FB5,0x9FC1C4,0x9FF638,0xA022DD,0xA03265,0xA0FF5B,0xA14F0B,0xA16DFE,0xA17BBC,0xA1BC55,0xA1F5D3,0xA26FD3,0xA2CB93,0xA3C583,0xA4D2ED,0xA4E3F8,0xA50D13,0xA572E3,0xA59521,0xA59960,0xA5B796,0xA75FB3,0xA819F3,0xA81A67,0xC33F91,0xC357AF,0xC35BF6,0xC3654D,0xC368CA,0xCA459A,0xD5B310,0xD5B84C,0xD5C74C,0xD5D64C,0xDAE2B3,0xDD2C33,0xE0DF33,0xE322D9,0xE34C61,0xE6C193,0xE78633,0xE78708,0xE78C0C,0xE7EF75,0xE87493,0xEA5B5A,0xEE6D2F,0xEE7AC7,0xEE8319,0xEE9A3A,0xEEAA44,0xEEE1F3,0x1011177,0x1011376,0x1012BB3,0x1016D07,0x1017455,0x1017E5B,0x1017EFE,0x1018BBE,0x12174D0,0x121A72F,0x1241F43,0x1245F36,0x1246173,0x12499D2,0x125AA73,0x125AB03,0x125D0AA,0x125D2B7,0x1264B43,0x1267133,0x127D303,0x127E211,0x12BFBB4,0x12BFE02,0x12C0E77,0x12C2037,0x12C254F,0x12C2D90,0x12C3A42,0x12C417C,0x13B6ED6,0x13B7709,0x13BC953,0x13CD791,0x1413303,0x1413B12,0x1440073,0x144C02A,0x144CF18,0x14733E3,0x1677B53,0x167ADB2,0x167B1A4,0x167B8C6,0x167D48D,0x167EAB8,0x167FCDE,0x167FF2C,0x168017A,0x1680AB6,0x1680B79,0x1681E14,0x1682E15,0x168368E,0x1684CDC,0x1687192,0x16875A7,0x16884B5,0x1688C85,0x1689455,0x1689C25,0x168A3F5,0x168ABC5,0x168B395,0x168BE4D,0x168BEBF,0x17DB3D9,0x17DF848,0x182ECA3,0x18579C3,0x18711CA,0x1871E4A,0x1872D5B,0x1881543,0x189B142,0x18C880B,0x18C8CF7,0x18C950D,0x18C9D92,0x18CCC95,0x18CEDB7,0x18D0EF5,0x18DD523,0x18DD609,0x18DFB0E,0x1AF3EE9,0x1AF6231,0x1AF891F,0x1AF9F3A,0x1AFADF7,0x1AFBDC3,0x1AFC997,0x1AFD87F,0x1AFDC08,0x1AFFB82,0x1AFFEED,0x1B01428,0x1B0149A,0x1B0206D,0x1B02C40,0x1B03813,0x1B043E6,0x1B04FB9,0x1B05B8C,0x1B069FA,0x1B21073,0x1B2111E,0x1B21EBD,0x1C14F23,0x1C2F993,0x1C41969,0x1C87753,0x1C8A121,0x1C8A35E,0x1C8C969,0x1C92883,0x1CB21C3,0x1CB2843,0x1CB2AFB,0x1DDB9EF,0x1DDC8E6,0x1E7F953,0x1EB00E6,0x1EB189A,0x1EB1AE2,0x1EB1D2A,0x1EB21E1,0x1EB3477,0x1EB3B4E,0x1EB3D8D,0x1EB7BE9,0x1EB80CD,0x1EB88BD,0x1EBF834,0x1EBFC63,0x1EC6D7B,0x1EC7079,0x1EC770D,0x1EC7D56,0x1EE92C7,0x1EE9467,0x1EEC2A2,0x1EEC4F0,0x1EEC73E,0x1EFB29C,0x1F05C2F,0x1F0FADF,0x1F1005D,0x1F1432D,0x1F14610,0x1F147B0,0x1F20B23,0x1F2C28E,0x1F2C6CF,0x1F3BA53,0x1F56E58,0x1F57509,0x1F580D7,0x1F62F13,0x1F76D89,0x1F78644,0x1F79C6A,0x1F7A47F,0x1F8EE53,0x1F9FA96,0x1FA1DE1,0x1FA9513,0x1FA9DB4,0x1FAFCA3,0x1FC3193,0x20540E3,0x20633AE,0x20638EA,0x206AFB5,0x206B720,0x207D0D3,0x2081B7D,0x2517B33,0x2D06CB5,0x2D0FEFE };
local int i;

for (i = 0; i < sizeof(mco_offsets)/sizeof(int); i++) {
    skip_mco = false;

    FSeek(mco_offsets[i]);
    mesh_container_outer mco;
}

/*
local int i = 0;
local int j = 0;
local int64 szms_start;
local int64 szms_start_real;
local int64 szms_start_maybe;
local int64 field_0x40;

local int found = 0;

local int found_count = 0;

while (true) {
    szms_start = FindFirst("SZMS\x04\x00\x00\x00", true, false, 0, 0.0, 1, FTell());
    if (szms_start == -1)
        break;

    field_0x40 = 0;

    found = 0;
    for (j = 0; j < 0xB; j++) {
        if ((ReadUShort(szms_start - 4 - 6 - j * 4) == 0xFFFF) &&
            ((ReadUByte (szms_start - 4 - 4 - j * 4) == 0x01) ||
             (ReadUByte (szms_start - 4 - 4 - j * 4) == 0x00))) {
            if (ReadUByte (szms_start - 4 - 1 - j * 4) == j) {
                field_0x40 = j;
                found = 1;
            }
            break;
        }
    }
    if (found == 0) {
        Printf("[0x%X] not found!\n", szms_start);
    }


    szms_start_real = szms_start - 4 - (4 * field_0x40 + 1);

    if (field_0x40 != 0)
        Printf("[0x%X] SZMS container f40 0x%X\n", szms_start_real, field_0x40);

    FSeek(szms_start_real);
    szms_container szms_container_;
    
    i += 1;
}
*/