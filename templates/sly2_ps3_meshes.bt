
//
// Initialization
//

LittleEndian();
DisplayFormatHex();

local int parse_meshes = false;
local int parse_entities_experimental = false;


//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}


//
// Type definitions (and Read functions)
//

// Common types

typedef ubyte u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;
typedef byte s8;
typedef int16 s16;
typedef int32 s32;
typedef int64 s64;
typedef float f32;
typedef double f64;

typedef struct bvec4_t
{
    uchar x, y, z, w;
} bvec4 <read=read_bvec4, bgcolor=cLtBlue>;
string read_bvec4(bvec4 &v) {
    string s;
    SPrintf(s, "[%02X %02X %02X %02X]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct uvec3_t
{
    uint32 x, y, z;
} uvec3 <read=read_uvec3, bgcolor=cDkBlue>;
string read_uvec3(uvec3 &v) {
    string s;
    SPrintf(s, "[%d %d %d]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct svec2_t
{
    uint16 x, y;
} svec2 <read=read_svec2, bgcolor=cDkBlue>;
string read_svec2(svec2 &v) {
    string s;
    SPrintf(s, "[%d %d %d]", v.x, v.y);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    if (pad_size != 0)
        byte pad[pad_size];
} align <optimize=false>;


// SZMS stuff

typedef struct szms_header_t
{
    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'S');
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow, optimize=false>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue, optimize=false>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct vertex_t
{
    vec3 pos;
    vec3 normal;
    vec2 texcoord;
    uint32 color;
} vertex <read=read_vertex, bgcolor=cLtPurple, optimize=false>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos.x, v.pos.y, v.pos.z, v.normal.x, v.normal.y, v.normal.z,
        v.texcoord.x,  v.texcoord.y, v.color);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cLtYellow, optimize=false>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 triangle_data_offset;
    uint32 index_data_offset;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.triangle_data_offset, v.index_data_offset);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr1;
    index_header index_hdr2;

    FSeek(start_offset + index_hdr1.triangle_data_offset);
    uint16  triangle_data1[index_hdr1.triangle_count * 3];

    FSeek(start_offset + index_hdr1.index_data_offset);
    uint16  index_data1[index_hdr1.index_count];

    // wrong?

    FSeek(start_offset + index_hdr2.triangle_data_offset);
    uint16  triangle_data2[index_hdr2.triangle_count * 3];

    FSeek(start_offset + index_hdr2.index_data_offset);
    uint16  index_data2[index_hdr2.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen, optimize=false>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua, optimize=false>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

typedef struct e2_t {
    u32 f0;
    u16 f1;
} e2;

typedef struct j10_t {
    u16 j1_cnt;
    svec2 j1;
} j10 <optimize=false, bgcolor=cDkRed>;

typedef struct j9_t {
    u16 j0_cnt;

    if (j0_cnt > 0) {
    j10 j0_[j0_cnt];
    }
} j9 <optimize=false, bgcolor=cDkGreen>;

typedef struct u2_t (u8 flags) {
    u8 g0;

    u32 g1; // TODO
    u16 g2;
    
    vec3 g3_mat4_0;
    vec3 g3_mat4_1;
    vec3 g3_mat4_2;
    vec3 g3_mat4_3;

    u32 g4;

    u8 g5_ign;

    j9 j9_;
} u2 <optimize=false, bgcolor=cBlue>;

u8 min(u8 x, u8 y) {
    if (x < y)
        return x;
    else
        return y;
}

typedef struct szme_data_t (u8 flags, u16 u2_cnt, u8 e2_cnt) {
    u8 a0_cnt;

    local uint a0_unk_cnt = 0;

    local int i = 0;
    for (i = 0; i < a0_cnt; i++) {
        uvec3 a0;
        a0_unk_cnt += a0.x;
    }

    u8 vertex_count;
    vec3 positions[vertex_count];
    vec2 texcoords[vertex_count];
    vec3 normals[vertex_count];
    uint32 a4[vertex_count];

    u8 a5;

    if (e2_cnt != 0) {
        u8 a7[4];

        local u8 e2_cnt_mn = min(e2_cnt, 4);
        u8 a8[vertex_count * e2_cnt_mn];
    }

    if (a0_unk_cnt > 0)
        u8 indices_unk[a0_unk_cnt];

    local u32 uVar28 = a0_unk_cnt + 0x1f;
    local u32 a6_uint_cnt = ((int)uVar28 >> 5) + (uint)((int)uVar28 < 0 && (uVar28 & 0x1f) != 0);
    if (a6_uint_cnt > 0)
        u32 a6[a6_uint_cnt];

    if (u2_cnt > 0)
        u2 u2_ (flags) [u2_cnt];
} szme_data <optimize=false, bgcolor=cYellow>;

typedef struct e17_t {
    u16 count;
    if (count != 0)
        Assert(false); // TODO
} e17;

typedef struct szme_t_ (u16 u2_cnt) {
    u8 flags;
    u16 e1;
    u8 e2_cnt;
    if (e2_cnt > 0)
        e2 e2_[e2_cnt];
    
    u8 e3;

    if (e3 != 0xFF) {
        vec3 e4;
        vec2 e5;
        vec3 e6;
    }    

    if ((flags & 4) != 0) {
        u32 e7;
        u8 e8;

        if (e8 != 0xFF) {
            u32 e9;
            u32 e10;
            u32 e11;
            u32 e12;

            vec3 e13_mat4_0;
            vec3 e13_mat4_1;
            vec3 e13_mat4_2;
            vec3 e13_mat4_3;
        }

        u8 e14;
        u8 e15;
        u8 e16;
    }

    u16 e17_cnt;
    if (e17_cnt > 0)
        e17 e17_[e17_cnt];

    u16 szme_data_cnt;
    szme_data szme_data_ (flags, u2_cnt, e2_cnt) [szme_data_cnt];
} szme_t <optimize=false, bgcolor=cLtGreen>;
string read_szme_t(szme_t &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "szme#: %d", v.mesh_count);
    }
    return s;
}

typedef struct mesh_data_t0_t (u16 u2_cnt) {
    szms_header szms;

    local int64 start_offset = FTell();

    mesh_header mesh_hdr;

    local uint32 i = 0;
    for (i = 0; i < mesh_hdr.mesh_count; ++i)
    {
        FSeek(start_offset + mesh_hdr.mesh_offsets[i]);

        vertex_data vertex_data_(start_offset);
    }

    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'E');

    szme_t szme (u2_cnt);
} mesh_data_t0 <open=true, bgcolor=cDkRed>;

typedef struct mesh_data_t (ubyte i0)
{
    ubyte u0;

    if (u0 == 0) {
        ubyte type;
        uint16 u2_cnt;
        uint16 u3;
        ubyte u3_;
        uint32 u4;
        uint32 u5_ign;
        uint32 u6;
        ubyte u7_ign;
        ubyte u8_;

        if (i0 == 0) {
            vec3 u9;
            u32 u10_ign;
            u32 u11;
            u32 u12_ign;
        }
        if (type == 0) {
             mesh_data_t0 t0 (u2_cnt);
        } else if (type == 1) {
            Assert(true, "type == 1"); // TODO
        } else if (type == 2) {
            Assert(true, "type == 2"); // TODO
        } else if (type == 3) {
            Assert(true, "type == 3"); // TODO
        }
    } else {
        u16 u1_alt[u0];
        u32 u2_ign_cnt;
        if (u2_ign_cnt > 0)
            u8 u2_ign[u2_ign_cnt];
    }
} mesh_data <read=read_mesh_data, bgcolor=cDkYellow, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;

/*
    SPrintf(s, "flags: %02X", v.flags);

    if ((v.flags & 1) == 0) {
        SPrintf(s, "%s %s", s, read_szms_header(v.szms));
        SPrintf(s, "%s %s", s, read_mesh_header(v.mesh_hdr));
        SPrintf(s, "%s %s", s, read_szme_t(v.szme));
    } else {
        // TDDO
    }
*/

    //SPrintf(s, "%s", s);
    return s;
}

typedef struct szms_container_t {
    ubyte i0;
    vec3 i1;
    uint32 i2;
    ubyte i3;
    ubyte i4;

    uint16 szms_count <bgcolor=cRed>;
    mesh_data mesh (i0) [szms_count - 1];
} szms_container <bgcolor=cDkGreen, read=read_szms_container, optimize=false>;
string read_szms_container(szms_container &v) {
    string s;
    SPrintf(s, "count: %d", v.szms_count);
    return s;
}


//
// Object allocation
//

// todo: connect with obj names?

FSeek(0x110828);
szms_container szms_container_;

/*
local int i = 0;
local int j = 0;
local int64 szms_start;
local int64 szms_start_real;
local int64 szms_start_maybe;
local int64 field_0x40;

local int found = 0;

local int found_count = 0;

while (true) {
    szms_start = FindFirst("SZMS\x04\x00\x00\x00", true, false, 0, 0.0, 1, FTell());
    if (szms_start == -1)
        break;

    field_0x40 = 0;

    found = 0;
    for (j = 0; j < 0xB; j++) {
        if ((ReadUShort(szms_start - 4 - 6 - j * 4) == 0xFFFF) &&
            ((ReadUByte (szms_start - 4 - 4 - j * 4) == 0x01) ||
             (ReadUByte (szms_start - 4 - 4 - j * 4) == 0x00))) {
            if (ReadUByte (szms_start - 4 - 1 - j * 4) == j) {
                field_0x40 = j;
                found = 1;
            }
            break;
        }
    }
    if (found == 0) {
        Printf("[0x%X] not found!\n", szms_start);
    }


    szms_start_real = szms_start - 4 - (4 * field_0x40 + 1);

    if (field_0x40 != 0)
        Printf("[0x%X] SZMS container f40 0x%X\n", szms_start_real, field_0x40);

    FSeek(szms_start_real);
    szms_container szms_container_;
    
    i += 1;
}
*/