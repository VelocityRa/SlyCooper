
//
// Initialization
//

LittleEndian();
DisplayFormatHex();

local int parse_meshes = false;
local int parse_entities_experimental = false;


//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}


//
// Type definitions (and Read functions)
//

// Common types

typedef ubyte u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;
typedef float f32;
typedef double f64;

typedef struct bvec4_t
{
    uchar x, y, z, w;
} bvec4 <read=read_bvec4, bgcolor=cDkPurple>;
string read_bvec4(bvec4 &v) {
    string s;
    SPrintf(s, "[%02X %02X %02X %02X]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cDkPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct uvec3_t
{
    uint32 x, y, z;
} uvec3 <read=read_uvec3, bgcolor=cDkPurple>;
string read_uvec3(uvec3 &v) {
    string s;
    SPrintf(s, "[%d %d %d]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    if (pad_size != 0)
        byte pad[pad_size];
} align <optimize=false>;


// SZMS stuff

typedef struct szms_header_t
{
    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'S');
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow, optimize=false>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue, optimize=false>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct vertex_t
{
    vec3 pos;
    vec3 normal;
    vec2 texcoord;
    uint32 color;
} vertex <read=read_vertex, bgcolor=cDkPurple, optimize=false>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos.x, v.pos.y, v.pos.z, v.normal.x, v.normal.y, v.normal.z,
        v.texcoord.x,  v.texcoord.y, v.color);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cPurple, optimize=false>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 triangle_data_offset;
    uint32 index_data_offset;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.triangle_data_offset, v.index_data_offset);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr1;
    index_header index_hdr2;

    FSeek(start_offset + index_hdr1.triangle_data_offset);
    uint16  triangle_data1[index_hdr1.triangle_count * 3];

    FSeek(start_offset + index_hdr1.index_data_offset);
    uint16  index_data1[index_hdr1.index_count];

    // wrong?

    FSeek(start_offset + index_hdr2.triangle_data_offset);
    uint16  triangle_data2[index_hdr2.triangle_count * 3];

    FSeek(start_offset + index_hdr2.index_data_offset);
    uint16  index_data2[index_hdr2.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen, optimize=false>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua, optimize=false>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

local uint16 g_flags = 0;

typedef struct after_szme_data_nested_t (ubyte field_0x40, ubyte unk_count_parent) {
    ubyte unk_count;
    vec3 unk_vec[unk_count];
    
    // TODO ubyte ?
    uint16 unk[unk_count_parent*field_0x40];
} after_szme_data_nested <optimize=false>;

typedef struct after_szme_data_t (ubyte field_0x40) {
    ubyte unk_count_;
    vec3 unk_vec[unk_count_];

    ubyte unk_count2;
    uint32 unk_u32[unk_count2];

    ubyte unk_count3_;
    ubyte unk_u8[unk_count3_];

    float unk_float[(uint32)unk_count_ * unk_count3_];

    if (field_0x40 != 0)
        after_szme_data_nested_t nested (field_0x40, unk_count_);
} after_szme_data <bgcolor=cAqua, optimize=false>;

typedef struct field_0x40_data_nested_t (ubyte field_0x40, ubyte indices_count) {
    uint16 unk[indices_count];

    // TODO: corret logic for these. depends on mesh index?
    //uint16 unk2[field_0x40 * 2]; // these are 2 interleaved arrays
} field_0x40_data_nested <optimize=false>;

typedef struct field_0x40_data_t (ubyte field_0x40, ubyte indices_count) {
    uint16 pos_count;
    vec3 positions[pos_count];

    uint16 norm_count;
    vec3 normals[norm_count];

    uint16 triangle_list[indices_count];

    local int nested_count = field_0x40 * 2 - 1;
/*
    else if (field_0x40 == 8)
        nested_count = 15;
    else if (field_0x40 == 4)
        nested_count = 7;
*/
/*
    if (field_0x40 == 1)
        nested_count = 1;
    else
        nested_count = field_0x40 * 2 - 1;
*/
    

    field_0x40_data_nested nested (field_0x40, indices_count) [nested_count];
} field_0x40_data <bgcolor=cGreen, optimize=false>;

typedef struct szme_vertex_data_t (ubyte field_0x40) {
    vec3 origin;
    float unk_float;
    ubyte unk_count1;
    ubyte unk_count2;
    ubyte unk_count3;
    ubyte unk_count4;
    ubyte indices_count;

    align _pad(4);

    vec3 positions[unk_count1];
    vec3 rotations[unk_count2];
    uint32 unk_color[unk_count3];
    vec2 texcoords[unk_count4];
    bvec4 indices[indices_count];

    uint16 texture_id;

    byte unk_u8_1;
    ubyte unk_count6;

    ubyte unk_bytes[unk_count6];
    float unk_floats[unk_count6 * unk_count1];

    if (field_0x40 != 0) {
        field_0x40_data f_0x40 (field_0x40, indices_count);
    }

    // TODO: field_0x40
} szme_vertex_data <optimize=false>;

typedef struct e2_t {
    u32 f0;
    u16 f1;
} e2;

typedef struct u2_t {
} u2 <optimize=false, bgcolor=cCyan>;

typedef struct szme_data_t (u16 u2_cnt, u8 e2_cnt) {
    u8 a0_cnt;

    local uint a0_unk_cnt = 0;

    local int i = 0;
    for (i = 0; i < a0_cnt; i++) {
        uvec3 a0;
        a0_unk_cnt += a0.x;
    }

    u8 vertex_count;
    vec3 positions[vertex_count];
    vec2 texcoords[vertex_count];
    vec3 normals[vertex_count];
    uint32 a4[vertex_count];

    if (e2_cnt != 0) {
        Assert(false);
    }
    u8 a5;
    u8 indices_unk[a0_unk_cnt];

    if (a0_unk_cnt != 0) // TODO: ???
        u32 a6;

    u2 u2_[u2_cnt];
} szme_data <optimize=false, bgcolor=cYellow>;

typedef struct e17_t {
    u16 count;
    if (count != 0)
        Assert(false); // TODO
} e17;

typedef struct szme_t_ (u16 u2_cnt) {
    u8 flags;
    u16 e1;
    u8 e2_cnt;
    if (e2_cnt > 0)
        e2 e2_[e2_cnt];
    
    u8 e3;

    if (e3 != 0xFF) {
        vec3 e4;
        vec2 e5;
        vec3 e6;
    }    

    if ((flags & 4) != 0) {
        u32 e7;
        u8 e8;

        if (e8 != 0xFF) {
            u32 e9;
            u32 e10;
            u32 e11;
            u32 e12;

            vec3 e13_mat4_0;
            vec3 e13_mat4_1;
            vec3 e13_mat4_2;
            vec3 e13_mat4_3;
        }

        u8 e14;
        u8 e15;
        u8 e16;
    }

    u16 e17_cnt;
    if (e17_cnt > 0)
        e17 e17_[e17_cnt];

    u16 szme_data_cnt;
    szme_data szme_data_ (u2_cnt, e2_cnt) [szme_data_cnt];
    
/*
    ubyte unk_u16_0;
    ubyte unk_u8_1_cnt;
    ubyte unk0 [unk_u8_1_cnt * 6]; // todo
    ubyte unk_u8_2;
    if (unk_u8_2 != (ubyte)-1) {
        //  todo: floats?
        vec3 v3_0;
        vec3 v2_0;
        vec3 v3_1;
    }
        
    ubyte unk_u16_1;
    ubyte unk_u16_2;
    ubyte unk_u8_3;
*/

/*
    vec3 position;
    float unk_0x14 <bgcolor=cAqua>;
    uint16 unk_0x16_ignore <bgcolor=cAqua>;
    byte unk_0x1A <bgcolor=cAqua>;
    byte unk_0x1B <bgcolor=cAqua>;
    byte unk_0x1C <bgcolor=cAqua>;

    if ((flags & 1) == 0) {
        uint16 mesh_count;
        //align _align(4);

        szme_vertex_data szme_data (field_0x40) [szme.mesh_count];
        uint16 after_szme_data_count;
        // TODO
        after_szme_data after_szme_data_ (field_0x40) [after_szme_data_count];
    }
*/
} szme_t <optimize=false, bgcolor=cLtGreen>;
string read_szme_t(szme_t &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "szme#: %d", v.mesh_count);
    }
    return s;
}

typedef struct mesh_data_t0_t (u16 u2_cnt) {
    szms_header szms;

    local int64 start_offset = FTell();

    mesh_header mesh_hdr;

    local uint32 i = 0;
    for (i = 0; i < mesh_hdr.mesh_count; ++i)
    {
        FSeek(start_offset + mesh_hdr.mesh_offsets[i]);

        vertex_data vertex_data_(start_offset);
    }

    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'E');

    szme_t szme (u2_cnt);
} mesh_data_t0 <open=true, bgcolor=cDkRed>;

typedef struct mesh_data_t (ubyte i0)
{
    ubyte u0;

    if (u0 == 0) {
        ubyte type;
        uint16 u2;
        uint16 u3;
        ubyte u3;
        uint32 u4;
        uint32 u5_ign;
        uint32 u6;
        ubyte u7_ign;
        ubyte u8_;

        if (i0 == 0) {
            vec3 u9;
            u32 u10_ign;
            u32 u11;
            u32 u12_ign;
        }
        if (type == 0) {
             mesh_data_t0 t0 (u2_cnt);
        } else if (type == 1) {
            Assert(true, "type == 1"); // TODO
        } else if (type == 2) {
            Assert(true, "type == 2"); // TODO
        } else if (type == 3) {
            Assert(true, "type == 3"); // TODO
        }
    } else {
        Assert(false); // TODO
    }

/*
    szms_header szms;

    local int64 start_offset = FTell();

    mesh_header mesh_hdr;

    local uint32 i = 0;
    for (i = 0; i < mesh_hdr.mesh_count; ++i)
    {
        FSeek(start_offset + mesh_hdr.mesh_offsets[i]);

        vertex_data vertex_data_(start_offset);
    }

    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'E');

    szme_t szme(field_0x40);

    //if ((flags & 0x100) == 0) { // TODO: remove when we parse 0x100 case
        //if (szme.mesh_count < 0xFF) { // todo
            //szme_vertex_data szme_data[szme.mesh_count];

            //uint16 unk_count;
            //after_szme_data after_szme_data_[unk_count];
        //}
    //} else {
    //    Assert(true, "0x100 case");
    //}
*/
} mesh_data <read=read_mesh_data, bgcolor=cDkGray, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;

/*
    SPrintf(s, "flags: %02X", v.flags);

    if ((v.flags & 1) == 0) {
        SPrintf(s, "%s %s", s, read_szms_header(v.szms));
        SPrintf(s, "%s %s", s, read_mesh_header(v.mesh_hdr));
        SPrintf(s, "%s %s", s, read_szme_t(v.szme));
    } else {
        // TDDO
    }
*/

    //SPrintf(s, "%s", s);
    return s;
}

typedef struct szms_container_t {
    ubyte i0;
    vec3 i1;
    uint32 i2;
    ubyte i3;
    ubyte i4;

    uint16 szms_count <bgcolor=cRed>;
    mesh_data mesh (i0) [szms_count];

/*
    ubyte field_0x40;
    if (field_0x40 != 0)
        uint32 unk_u32s[field_0x40];
    uint16 szms_count <bgcolor=cRed>;
    mesh_data mesh (field_0x40) [szms_count];

    uint32 flags2;
    if (flags2 & 1) {
        vec3 unk_mat_0;
        vec3 unk_mat_1;
        vec3 unk_mat_2;
    }
    if (flags2 & 2) {
        vec3 unk_mat2_0;
        vec3 unk_mat2_1;
        vec3 unk_mat2_2;
    }
    if (flags2 & 0xC) {
        uint16 unk_u16;
    }
    if (flags2 & 0x10) {
        uint16 unk_u16_2;
    }
    if (flags2 & 0x20) {
        uint16 unk_u16_2;
        vec3 unk_vec;
        vec3 unk_vec2;
        float unk_float;
    }
    if (flags2 & 0x40) {
        uint16 unk_u16_3;
        uint16 unk_u16_4;
    }
    if (flags2 & 0x80) {
        ubyte unk_u8;
    }

    ubyte unk_count;
    //if (unk_count != 0)
    //    Assert(false);
    struct unk_t {
        uint16 unk_u16;
        float unk_float[field_0x40];
    } unk_struct[unk_count];

    uint16 unk_count2;
    if (unk_count2 != 0)
        ; // Assert(false);
*/
} szms_container <bgcolor=cDkGreen, read=read_szms_container, optimize=false>;
string read_szms_container(szms_container &v) {
    string s;
    SPrintf(s, "count: %d", v.szms_count);
    return s;
}


//
// Object allocation
//

// todo: connect with obj names?

FSeek(0x110828);
szms_container szms_container_;

/*
local int i = 0;
local int j = 0;
local int64 szms_start;
local int64 szms_start_real;
local int64 szms_start_maybe;
local int64 field_0x40;

local int found = 0;

local int found_count = 0;

while (true) {
    szms_start = FindFirst("SZMS\x04\x00\x00\x00", true, false, 0, 0.0, 1, FTell());
    if (szms_start == -1)
        break;

    field_0x40 = 0;

    found = 0;
    for (j = 0; j < 0xB; j++) {
        if ((ReadUShort(szms_start - 4 - 6 - j * 4) == 0xFFFF) &&
            ((ReadUByte (szms_start - 4 - 4 - j * 4) == 0x01) ||
             (ReadUByte (szms_start - 4 - 4 - j * 4) == 0x00))) {
            if (ReadUByte (szms_start - 4 - 1 - j * 4) == j) {
                field_0x40 = j;
                found = 1;
            }
            break;
        }
    }
    if (found == 0) {
        Printf("[0x%X] not found!\n", szms_start);
    }


    szms_start_real = szms_start - 4 - (4 * field_0x40 + 1);

    if (field_0x40 != 0)
        Printf("[0x%X] SZMS container f40 0x%X\n", szms_start_real, field_0x40);

    FSeek(szms_start_real);
    szms_container szms_container_;
    
    i += 1;
}
*/