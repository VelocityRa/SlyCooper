
//
// Initialization
//

LittleEndian();
DisplayFormatHex();

local int parse_meshes = false;
local int parse_entities_experimental = false;


//
// Utility functions
//

void hexdump(int64 pos, int n) {
    local uchar buf[n];
    ReadBytes(buf, pos, n);

    local int i;
    for (i = 0; i < n; ++i) {
        Printf("%02X", buf[i]);
        if (i % 4 == 3)
            Printf(" ");
    }
}


//
// Type definitions (and Read functions)
//

// Common types

typedef ubyte u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;
typedef byte s8;
typedef int16 s16;
typedef int32 s32;
typedef int64 s64;
typedef float f32;
typedef double f64;

typedef struct bvec4_t
{
    uchar x, y, z, w;
} bvec4 <read=read_bvec4, bgcolor=cLtBlue>;
string read_bvec4(bvec4 &v) {
    string s;
    SPrintf(s, "[%02X %02X %02X %02X]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct vec2_t
{
    float x, y;
} vec2 <read=read_vec2, bgcolor=cPurple>;
string read_vec2(vec2 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f]",
        v.x, v.y);
    return s;
}

typedef struct vec3_t
{
    float x, y, z;
} vec3 <read=read_vec3, bgcolor=cDkPurple>;
string read_vec3(vec3 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z);
    return s;
}

typedef struct uvec3_t
{
    uint32 x, y, z;
} uvec3 <read=read_uvec3, bgcolor=cDkBlue>;
string read_uvec3(uvec3 &v) {
    string s;
    SPrintf(s, "[%d %d %d]",
        v.x, v.y, v.z);
    return s;
}

typedef struct vec4_t
{
    float x, y, z, w;
} vec4 <read=read_vec4, bgcolor=cDkPurple>;
string read_vec4(vec4 &v) {
    string s;
    SPrintf(s, "[%7.3f \t%7.3f \t%7.3f \t%7.3f]",
        v.x, v.y, v.z, v.w);
    return s;
}

typedef struct svec2_t
{
    uint16 x, y;
} svec2 <read=read_svec2, bgcolor=cDkBlue>;
string read_svec2(svec2 &v) {
    string s;
    SPrintf(s, "[%d %d %d]", v.x, v.y);
    return s;
}

typedef struct align_t (int alignment) {
    local int val = FTell();
    local int pad_size = (-val) & (alignment - 1);
    if (pad_size != 0)
        byte pad[pad_size];
} align <optimize=false>;


// SZMS stuff

typedef struct szms_header_t
{
    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'S');
    uint32 version <hidden=true>;
    Assert(version == 4);
    uint32 data_size;
} szms_header <read=read_szms_header, bgcolor=cYellow, optimize=false>;
string read_szms_header(szms_header &v) {
    string s;
    SPrintf(s, "size: %05X", v.data_size);
    return s;
}

typedef struct mesh_header_t
{
    uint32 unknown_0x00 <bgcolor=cAqua>;
    uint16 unknown_0x04 <bgcolor=cAqua>;
    uint16 mesh_count <format=decimal>;
    uint32 mesh_offsets[mesh_count];
} mesh_header <read=read_mesh_header, bgcolor=cBlue, optimize=false>;
string read_mesh_header(mesh_header &v) {
    string s;
    //SPrintf(s, "mesh#: %d unk0: 0x%08X unk1: 0x%04X",
    //    v.mesh_count, v.unknown_0x00, v.unknown_0x04);
    SPrintf(s, "mesh#: %d", v.mesh_count);
    return s;
}

typedef struct vertex_t
{
    vec3 pos;
    vec3 normal;
    vec2 texcoord;
    uint32 color;
} vertex <read=read_vertex, bgcolor=cLtPurple, optimize=false>;
string read_vertex(vertex &v) {
    string s;
    SPrintf(s, "[%7.2f \t%7.2f \t%7.2f] [%4.3f \t%4.3f \t%4.3f] [%4.3f \t%4.3f] \t0x%08X",
        v.pos.x, v.pos.y, v.pos.z, v.normal.x, v.normal.y, v.normal.z,
        v.texcoord.x,  v.texcoord.y, v.color);
    return s;
}

typedef struct vertex_header_t
{
    uint32 unknown_0x10  <bgcolor=cAqua>;
    uint16 vertex_count  <format=decimal>;
    uint16 unknown_count <format=decimal, bgcolor=cAqua>;
    uint32 vertex_data_offset;
    uint32 index_header_offset;

    local uint32 vertex_data_size = index_header_offset - vertex_data_offset;

    // Sanity-check that all verts are of the size we assume
    local uint32 vertex_single_size = vertex_data_size / vertex_count;
    Assert(vertex_single_size == sizeof(vertex_t));
} vertex_header <read=read_vertex_header, bgcolor=cLtYellow, optimize=false>;
string read_vertex_header(vertex_header &v) {
    string s;
    SPrintf(s, "vtx#: %d unk#: %d vtx_off: 0x%X idx_off: 0x%X vtx_data_size: 0x%X",
        v.vertex_count, v.unknown_count, v.vertex_data_offset, v.index_header_offset, v.vertex_data_size);
    return s;
}

typedef struct index_header_t
{
    uint16 triangle_count <format=decimal>;
    uint16 index_count    <format=decimal>;
    uint32 triangle_data_offset;
    uint32 index_data_offset;
} index_header <read=read_index_header, bgcolor=cRed>;
string read_index_header(index_header &v) {
    string s;
    SPrintf(s, "tri#: %d idx#: %d off1: 0x%X off2: 0x%X",
        v.triangle_count, v.index_count, v.triangle_data_offset, v.index_data_offset);
    return s;
}

typedef struct index_data_t(int64 start_offset)
{
    index_header index_hdr1;
    index_header index_hdr2;

    FSeek(start_offset + index_hdr1.triangle_data_offset);
    uint16  triangle_data1[index_hdr1.triangle_count * 3];

    FSeek(start_offset + index_hdr1.index_data_offset);
    uint16  index_data1[index_hdr1.index_count];

    // wrong?

    FSeek(start_offset + index_hdr2.triangle_data_offset);
    uint16  triangle_data2[index_hdr2.triangle_count * 3];

    FSeek(start_offset + index_hdr2.index_data_offset);
    uint16  index_data2[index_hdr2.index_count];
} index_data <read=read_index_data, bgcolor=cDkGreen, optimize=false>;
string read_index_data(index_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

typedef struct vertex_data_t(int64 start_offset)
{
    vertex_header vertex_hdr;

    FSeek(start_offset + vertex_hdr.vertex_data_offset);
    vertex vertices[vertex_hdr.vertex_count];

    FSeek(start_offset + vertex_hdr.index_header_offset);
    index_data index_hdr(start_offset);
} vertex_data <read=read_vertex_data, bgcolor=cDkAqua, optimize=false>;
string read_vertex_data(vertex_data &v) {
    string s;
    SPrintf(s, "");
    return s;
}

// SZME stuff

typedef struct e2_t {
    u32 f0;
    u16 f1;
} e2;

typedef struct j10_t {
    u16 j1_cnt;
    svec2 j1;
} j10 <optimize=false, bgcolor=cDkRed>;

typedef struct j9_t {
    u16 j0_cnt;

    if (j0_cnt > 0) {
    j10 j0_[j0_cnt];
    }
} j9 <optimize=false, bgcolor=cDkGreen>;

typedef struct u2_t (u8 flags) {
    u8 g0;

    u32 g1; // TODO
    u16 g2;
    
    vec3 g3_mat4_0;
    vec3 g3_mat4_1;
    vec3 g3_mat4_2;
    vec3 g3_mat4_3;

    u32 g4;

    u8 g5_ign;

    j9 j9_;
} u2 <optimize=false, bgcolor=cBlue>;

u8 min(u8 x, u8 y) {
    if (x < y)
        return x;
    else
        return y;
}

typedef struct szme_data_t (u8 flags, u16 u2_cnt, u8 e2_cnt) {
    u8 a0_cnt;

    local uint a0_unk_cnt = 0;

    local int i = 0;
    for (i = 0; i < a0_cnt; i++) {
        uvec3 a0;
        a0_unk_cnt += a0.x;
    }

    u8 vertex_count;
    vec3 positions[vertex_count];
    vec2 texcoords[vertex_count];
    vec3 normals[vertex_count];
    uint32 a4[vertex_count];

    u8 a5;

    if (e2_cnt != 0) {
        u8 a7[4];

        local u8 e2_cnt_mn = min(e2_cnt, 4);
        u8 a8[vertex_count * e2_cnt_mn];
    }

    if (a0_unk_cnt > 0)
        u8 indices_unk[a0_unk_cnt];

    local u32 uVar28 = a0_unk_cnt + 0x1f;
    local u32 a6_uint_cnt = ((int)uVar28 >> 5) + (uint)((int)uVar28 < 0 && (uVar28 & 0x1f) != 0);
    if (a6_uint_cnt > 0)
        u32 a6[a6_uint_cnt];

    if (u2_cnt > 0)
        u2 u2_ (flags) [u2_cnt];
} szme_data <optimize=false, bgcolor=cYellow>;

typedef struct e17_t {
    u16 count;
    if (count != 0)
        Assert(false); // TODO
} e17;

typedef struct szme_t_ (u16 u2_cnt) {
    u8 flags;
    u16 e1;
    u8 e2_cnt;
    if (e2_cnt > 0)
        e2 e2_[e2_cnt];
    
    u8 e3;

    if (e3 != 0xFF) {
        vec3 e4;
        vec2 e5;
        vec3 e6;
    }    

    if ((flags & 4) != 0) {
        u32 e7;
        u8 e8;

        if (e8 != 0xFF) {
            u32 e9;
            u32 e10;
            u32 e11;
            u32 e12;

            vec3 e13_mat4_0;
            vec3 e13_mat4_1;
            vec3 e13_mat4_2;
            vec3 e13_mat4_3;
        }

        u8 e14;
        u8 e15;
        u8 e16;
    }

    u16 e17_cnt;
    if (e17_cnt > 0)
        e17 e17_[e17_cnt];

    u16 szme_data_cnt;
    szme_data szme_data_ (flags, u2_cnt, e2_cnt) [szme_data_cnt];
} szme_t <optimize=false, bgcolor=cLtGreen>;
string read_szme_t(szme_t &v) {
    string s;
    if ((g_flags & 1) == 0) {
        SPrintf(s, "szme#: %d", v.mesh_count);
    }
    return s;
}

typedef struct mesh_data_t0_t (u16 u2_cnt) {
    szms_header szms;

    local int64 start_offset = FTell();

    mesh_header mesh_hdr;

    local uint32 i = 0;
    for (i = 0; i < mesh_hdr.mesh_count; ++i)
    {
        FSeek(start_offset + mesh_hdr.mesh_offsets[i]);

        vertex_data vertex_data_(start_offset);
    }

    char magic[4] <hidden=true>;
    Assert(magic[0] == 'S' && magic[1] == 'Z' && magic[2] == 'M' && magic[3] == 'E');

    szme_t szme (u2_cnt);
} mesh_data_t0 <open=true, bgcolor=cDkRed>;

typedef struct mesh_data_t (ubyte i0)
{
    ubyte u0;

    if (u0 == 0) {
        ubyte type;
        uint16 u2_cnt;
        uint16 u3;
        ubyte u3_;
        f32 u4;
        f32 u5;
        uint32 u6;
        ubyte u7_ign;
        ubyte u8_;

        if (i0 == 0) {
            vec3 u9;
            float u10;
            u32 u11;
            float u12;
        }
        if (type == 0) {
             mesh_data_t0 t0 (u2_cnt);
        } else if (type == 1) {
            Assert(false, "type == 1"); // TODO
        } else if (type == 2) {
            Assert(false, "type == 2"); // TODO
        } else if (type == 3) {
            Assert(false, "type == 3"); // TODO
        } else {
            Assert(false);
        }
    } else {
        u16 u1_alt[u0];
        u32 u2_ign_cnt;
        if (u2_ign_cnt > 0)
            u8 u2_ign[u2_ign_cnt];
    }
} mesh_data <read=read_mesh_data, bgcolor=cDkYellow, optimize=false>;
string read_mesh_data(mesh_data &v) {
    string s;

/*
    SPrintf(s, "flags: %02X", v.flags);

    if ((v.flags & 1) == 0) {
        SPrintf(s, "%s %s", s, read_szms_header(v.szms));
        SPrintf(s, "%s %s", s, read_mesh_header(v.mesh_hdr));
        SPrintf(s, "%s %s", s, read_szme_t(v.szme));
    } else {
        // TDDO
    }
*/

    //SPrintf(s, "%s", s);
    return s;
}

typedef struct mesh_data_unk3_t {
    u16 count;
    if (count > 0) {
        u8 k1[count];
        Assert(false);
    }
} mesh_data_unk3 <bgcolor=cGreen, optimize=false>;

typedef struct mesh_container_t {
    ubyte i0;
    vec3 i1;
    float i2;
    ubyte i3;
    ubyte i4;

    uint16 mesh_count <bgcolor=cRed>;
    mesh_data mesh (i0) [mesh_count - 1]; // TODO: why -1
    mesh_data_unk3 mesh_data_unk3_;
} mesh_container <bgcolor=cDkGreen, read=read_mesh_container, optimize=false>;
string read_mesh_container(mesh_container &v) {
    string s;
    SPrintf(s, "count: %d", v.mesh_count);
    return s;
}


typedef struct mesh_container_outer_c2_t {
    u16 c3;
    u16 c4;
    u32 c5;
    u8 flags;
    if ((flags & 1) == 0) {
        if ((flags & 2) != 0) {
            f32 c6;
            f32 c7;
        }
    } else {
        f32 c8;
    }
    if ((flags & 4) != 0) {
        u8 c9;
    }
    if ((flags & 8) != 0) {
        u8 c10;
        f32 c11;
        vec3 c12_mat_0;
        vec3 c12_mat_1;
        vec3 c12_mat_2;
        vec3 c12_mat_3;
        u8 c13;
        u8 c14;
        u32 c15;
    }
    if ((flags & 0x10) != 0) {
        u8 c16;
        f32 c17;
        f32 c18;
    }
    if ((flags & 0x20) != 0) {
        vec3 c19;
    }
    if (c4 < 0x10) {
        local u64 uVar8 = 1 << ((u64)(u32)c4 & 0x7F);
        if ((uVar8 & 0xA001) == 0) {
            if ((uVar8 & 0x4100) == 0) {
                vec3 c22_mat_0;
                vec3 c22_mat_1;
                vec3 c22_mat_2;
                vec3 c22_mat_3;
            } else {
                u16 c20;
            }
        } else {            
            vec3 c21_mat_0;
            vec3 c21_mat_1;
            vec3 c21_mat_2;
            vec3 c21_mat_3;
        }
    } else {        
        vec3 c22_mat_0;
        vec3 c22_mat_1;
        vec3 c22_mat_2;
        vec3 c22_mat_3;
    }
} mesh_container_outer_c2 <bgcolor=cDkRed, optimize=false>;

typedef struct ca_t {
    u16 ca0;
    u16 ca1;
    u16 ca2;
    vec3 ca3;
    u16 ca4;
    vec3 ca5;
} ca <bgcolor=cRed>;
typedef struct cb_t {
    u16 cb0;
    u16 cb1;
    u8 cb2;
    u8 cb3;
} cb <bgcolor=cDkRed>;
typedef struct cc_t {
    u8 cc0;
    f32 cc1;
    f32 cc2;
    f32 cc3;
    f32 cc4;
    vec3 cc5;
    vec3 cc6;
    u8 cc7_cnt;
    if (cc7_cnt > 0)
        u16 cc7[cc7_cnt];
} cc <bgcolor=cAqua>;

typedef struct cd5_t {
    u16 cd5_0;
    u16 cd5_1;
    u16 cd5_2;
} cd5 <bgcolor=cDkBlue>;

typedef struct cd_t {
    u16 cd0;
    u16 cd1_ign;
    u16 cd2_ign;
    f32 cd3_ign[4]; // ?
    u8 cd4;
    if (cd4 > 0)
        cd5 cd5_[cd4];
} cd <bgcolor=cDkYellow, optimize=false>;

typedef struct c6a_t {
    u16 c6a0_count;
    if (c6a0_count > 0)
        vec3 c6a0[c6a0_count];
    u16 cd_count;
    u16 c6a2;
    if (cd_count > 0)
        cd cd_[cd_count];
} c6a <bgcolor=cBlue>;

struct c7b {
    u16 c7b0;
    u32 c7b1;
    u32 c7b2;
};

typedef struct c7a_t {
    u32 c70;
    u32 c71;
    u32 c72;
    c7b c7b_[c70];
} c7a <bgcolor=cLtGreen>;

typedef struct c6_t {
    u16 c6_0;
    u32 c6_1;
    u8 c6_2;
    u8 c6_3;
    f32 c6_4;
    c6a c6a_;
    c7a c7a_;
    u32 c8a;
    u16 c9a;
    u16 c10a;
    u8 c11a;
} c6 <optimize=false, bgcolor=cLtRed>;

typedef struct mesh_container_outer_t {
    u16 c2_cnt;
    if (c2_cnt > 0)
        mesh_container_outer_c2 mco_c2[c2_cnt];

    u8 ca_count;
    if (ca_count > 0)
        ca ca_[ca_count];
    u8 cb_count;
    if (cb_count > 0)
        cb cb_[cb_count];
    u8 cc_count;
    if (cc_count > 0)
        cc cc_[cc_count];

    u16 c3;
    u16 c4;
    u16 c5;

    u32 c1;
    mesh_container mc;

    u16 c6_count;
    if (c6_count > 0) {
        c6 c6_[c6_count];
        f32 c7;
        vec3 c8_mat3_0;
        vec3 c8_mat3_1;
        vec3 c8_mat3_2;
    }

} mesh_container_outer <bgcolor=cGreen, read=read_mesh_container_outer, optimize=false>;
string read_mesh_container_outer(mesh_container_outer &v) {
    string s;
    SPrintf(s, "%s", read_mesh_container(v.mc));
    return s;
}

//
// Object allocation
//

// todo: connect with obj names?

//FSeek(0x110828);
//mesh_container mc;

FSeek(0x1106C3);
mesh_container_outer mco;

/*
local int i = 0;
local int j = 0;
local int64 szms_start;
local int64 szms_start_real;
local int64 szms_start_maybe;
local int64 field_0x40;

local int found = 0;

local int found_count = 0;

while (true) {
    szms_start = FindFirst("SZMS\x04\x00\x00\x00", true, false, 0, 0.0, 1, FTell());
    if (szms_start == -1)
        break;

    field_0x40 = 0;

    found = 0;
    for (j = 0; j < 0xB; j++) {
        if ((ReadUShort(szms_start - 4 - 6 - j * 4) == 0xFFFF) &&
            ((ReadUByte (szms_start - 4 - 4 - j * 4) == 0x01) ||
             (ReadUByte (szms_start - 4 - 4 - j * 4) == 0x00))) {
            if (ReadUByte (szms_start - 4 - 1 - j * 4) == j) {
                field_0x40 = j;
                found = 1;
            }
            break;
        }
    }
    if (found == 0) {
        Printf("[0x%X] not found!\n", szms_start);
    }


    szms_start_real = szms_start - 4 - (4 * field_0x40 + 1);

    if (field_0x40 != 0)
        Printf("[0x%X] SZMS container f40 0x%X\n", szms_start_real, field_0x40);

    FSeek(szms_start_real);
    szms_container szms_container_;
    
    i += 1;
}
*/